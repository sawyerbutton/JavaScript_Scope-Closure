# 认知JavaScript  

作用域和闭包(Scope and Closure)

---

### 作用域

- 什么是作用域？
- 语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值的能力
- 在变量中存储值和取出值的能力，给程序赋予状态这一概念
- 引入变量之后，这些变量存活在哪里？
- 这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。AKA：作用域

---
### 理解作用域
- 登场演员
- 引擎：负责从始至终的编译和执行我们的 JavaScript 程序
- 编译器：引擎 的朋友之一；处理所有的解析和代码生成的苦活累活
- 作用域：引擎 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。

---
### What happen for "var a = 2";

- 遇到 var a, 编译器 让 作用域 去查看对于这个特定的作用域集合，变量 a 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量
- 然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2, 引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就查看 其他地方

---

- 如果 引擎 最终找到一个变量，它就将值 2 赋予它, 如果没有，引擎 将会举起它的手并喊出一个错误！  
- 总结: 对于一个变量赋值，发生了两个不同的动作：第一，编译器 声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，引擎 在 作用域 中查询这个变量并给它赋值，如果找到的话

---
### 编译器术语
- LRS(Left-hand Side)  当一个变量出现在赋值操作的左手边时，会进行 LHS 查询
- RHS(Right-hand Side)  当一个变量出现在赋值操作的右手边时，会进行 RHS 查询

---
## console.log( a );
- 指向 a 的引用是一个 RHS 引用，因为这里没有东西被赋值给 a，而是我们在查询 a 并取得它的值，这样这个值可以被传递进 console.log(..)
---
## a = 2;
- a 的引用是一个 LHS 引用，因为我们实际上不关心当前的值是什么，我们只是想找到这个变量，将它作为 = 2 赋值操作的目标

### Attention

- LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ = 赋值操作符的左/右边”
- 赋值有几种其他的发生形式，所以最好在概念上将它考虑为："赋值的目标(LHS)"和“赋值的源(RHS)"

## Example
```javascript
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```
---
```
引擎：嘿 作用域，我有一个 foo 的 RHS 引用。听说过它吗？

作用域；啊，是的，听说过。编译器 刚在一秒钟之前声明了它。它是一个函数。给你。

引擎：太棒了，谢谢！好的，我要执行 foo 了。

引擎：嘿，作用域，我得到了一个 a 的 LHS 引用，听说过它吗？

作用域：啊，是的，听说过。编译器 刚才将它声明为 foo 的一个正式参数了。给你。

引擎：一如既往的给力，作用域。再次感谢你。现在，该把 2 赋值给 a 了。

引擎：嘿，作用域，很抱歉又一次打扰你。我需要 RHS 查询 console。听说过它吗？

作用域：没关系，引擎，这是我一天到晚的工作。是的，我得到 console 了。它是一个内建对象。给你。

引擎：完美。查找 log(..)。好的，很好，它是一个函数。

引擎：嘿，作用域。你能帮我查一下 a 的 RHS 引用吗？我想我记得它，但只是想再次确认一下。

作用域：你是对的，引擎。同一个家伙，没变。给你。

引擎：酷。传递 a 的值，也就是 2，给 log(..)
```
---


